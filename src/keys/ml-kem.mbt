///| KEM È´òÂ±ÇÂÜÖÈÉ®ÂØÜÈí•ÂØπÁîüÊàêÂáΩÊï∞ÔºàInternal Key Generation for KEMÔºâ  
///
/// Parameters
///
/// - `d` : Â≠óËäÇÊï∞ÁªÑÔºàByteArrayÔºâÔºå‰Ωú‰∏∫ PKE ÂØÜÈí•ÂØπÁîüÊàêÁöÑ‰∏ªÁÜµÊ∫ê
/// - `z` : Â≠óËäÇÊï∞ÁªÑÔºàByteArrayÔºâÔºåÁî®‰∫éÁßÅÈí•Êâ©Â±ïÈÉ®ÂàÜÁöÑÈôÑÂä†ÈöèÊú∫ÂÄº
///
/// Returns
///
/// - `(ByteArray, ByteArray)` : ËøîÂõû‰∫åÂÖÉÁªÑ (ek, dk)
///   - `ek` ÔºöÊâ©Â±ïÂÖ¨Èí•Â≠óËäÇÊï∞ÁªÑÔºàÂç≥ ek_PKEÔºâ
///   - `dk` ÔºöÊâ©Â±ïÁßÅÈí•Â≠óËäÇÊï∞ÁªÑÔºàÊ†ºÂºè‰∏∫ dk_PKE || ek || H(ek) || zÔºâ
///
/// Errors
///
/// - Êó†ÊòæÂºèÈîôËØØÊäõÂá∫Ôºå‰ΩÜ‰æùËµñÔºö
///   - `keygen`„ÄÅ`@kem.h` Á≠âÂáΩÊï∞Â∑≤Ê≠£Á°ÆÂÆö‰πâ
///   - ËæìÂÖ•ÂèÇÊï∞ÈïøÂ∫¶ÂíåÂÜÖÂÆπÂùáÊª°Ë∂≥ÂçèËÆÆË¶ÅÊ±Ç
///
/// Description
///
/// Ê≠§ÂáΩÊï∞‰∏∫ KEMÔºàÂØÜÈí•Â∞ÅË£ÖÊú∫Âà∂ÔºâÁîüÊàêÊâ©Â±ïÂØÜÈí•ÂØπÔºåÂåÖÂê´Â¶Ç‰∏ãÊ≠•È™§Ôºö
///
/// 1. **ÁîüÊàê PKE ÂØÜÈí•ÂØπ**Ôºö
///    - Ë∞ÉÁî® `keygen(d)` ÂæóÂà∞Âü∫Á°ÄÂÖ¨ÁßÅÈí•ÂØπ (`ek_PKE`, `dk_PKE`)
///
/// 2. **Êâ©Â±ïÂÖ¨Èí•**Ôºö
///    - Áõ¥Êé•Âèñ `ek_PKE` ‰Ωú‰∏∫ KEM ÁöÑÂÖ¨Èí• ek
///
/// 3. **Êâ©Â±ïÁßÅÈí•**Ôºö
///    - ÁßÅÈí• dk ÁªìÊûÑ‰∏∫Ôºö`dk_PKE || ek || H(ek) || z`
///    - ÂÖ∂‰∏≠ H(ek) Ë°®Á§∫ÂØπÂÖ¨Èí• ek ÁöÑÂìàÂ∏å
///    - z ‰∏∫Â§ñÈÉ®ÈôÑÂä†ÁöÑÁßÅÈí•ÁÜµÊ∫êÔºåÂ∏∏Áî®‰∫éÈò≤Êä§ÊïÖÈöúÊîªÂáªÊàñÂØÜÈí•Êõ¥Êñ∞
///
/// 4. **ËøîÂõûÂØÜÈí•ÂØπ**
///
/// Example
/// ```
/// let (ek, dk) = keygen_internal(d, z)
/// ```
pub fn keygen_internal(d : ByteArray, z : ByteArray) -> (ByteArray, ByteArray) {
  // 1. K-PKE ÂØÜÈí•ÂØπÁîüÊàê
  let (ek_PKE, dk_PKE) = k_keygen(d)
  // 2. ek = ek_PKE
  let ek = ek_PKE
  // 3. dk = dk_PKE || ek || H(ek) || z
  let h_ek = @kem.h(ek)
  let dk = dk_PKE.copy()
  dk.append(ek)
  dk.append(h_ek)
  dk.append(z)
  // 4. ËøîÂõû
  (ek, dk)
}

///| KEM ÂÜÖÈÉ®Â∞ÅË£ÖÂáΩÊï∞ÔºàInternal Encapsulation for KEMÔºâ  
///
/// Parameters
///
/// - `ek` : Êâ©Â±ïÂÖ¨Èí•Â≠óËäÇÊï∞ÁªÑÔºàByteArrayÔºâÔºåÁî± `keygen_internal` ÁîüÊàê
/// - `m`  : Â∞ÅË£ÖÁî®ÁöÑÊ∂àÊÅØÈöèÊú∫Êï∞ÔºàByteArrayÔºâÔºå‰∏ÄËà¨‰∏∫‰∏¥Êó∂ÁîüÊàêÁöÑÈöèÊú∫Êï∞ÊàñÂØÜÈí•ÊùêÊñô
///
/// Returns
///
/// - `(ByteArray, ByteArray)` : ËøîÂõû‰∫åÂÖÉÁªÑ (K, c)
///   - `K` ÔºöÂçèÂïÜÂá∫ÁöÑÂØÜÈí•ÔºàByteArrayÔºâÔºåÁî®‰∫éÂØπÁß∞Âä†ÂØÜÁ≠â
///   - `c` ÔºöÂØÜÊñáÔºàByteArrayÔºâÔºåÁî®‰∫éÂÆâÂÖ®‰º†Ëæì
///
/// Errors
///
/// - Êó†ÊòæÂºèÈîôËØØÊäõÂá∫Ôºå‰ΩÜ‰æùËµñÔºö
///   - `@kem.h`„ÄÅ`@kem.g`„ÄÅ`encrypt` Á≠âÂáΩÊï∞Â∑≤Ê≠£Á°ÆÂÆö‰πâ‰∏îÂÆâÂÖ®
///   - ËæìÂÖ•ÂèÇÊï∞Ê†ºÂºè‰∏éÂçèËÆÆ‰∏ÄËá¥
///
/// Description
///
/// Ê≠§ÂáΩÊï∞ÂÆûÁé∞ KEM ÂçèËÆÆ‰∏≠ÁöÑÂÜÖÈÉ®Â∞ÅË£ÖËøáÁ®ãÔºö
///
/// 1. **ÂØÜÈí•Ê¥æÁîü‰∏éÈöèÊú∫Êï∞ÁîüÊàê**Ôºö  
///    - ‰ª§ `input = m || H(ek)`ÔºåÂç≥Ê∂àÊÅØ‰∏éÂÖ¨Èí•ÂìàÂ∏åÊãºÊé•  
///    - ÈÄöËøáÊ¥æÁîüÂáΩÊï∞ `@kem.g(input)`ÔºåÂæóÂà∞ÂçèÂïÜÂØÜÈí• K ÂíåÈöèÊú∫Êï∞ r  
///
/// 2. **Âä†ÂØÜÊ∂àÊÅØ**Ôºö  
///    - Áî®Êâ©Â±ïÂÖ¨Èí• ek„ÄÅÊòéÊñá m„ÄÅÈöèÊú∫Êï∞ r Ë∞ÉÁî® `encrypt`ÔºåÁîüÊàêÂØÜÊñá c  
///
/// 3. **ËøîÂõû (K, c)**Ôºö  
///    - ËæìÂá∫ (K, c)ÔºåÂç≥ KEM Â∞ÅË£ÖËæìÂá∫  
///
/// ËØ•ÊµÅÁ®ã‰øùÈöú‰∫ÜÂØÜÈí•ÂçèÂïÜÁöÑÈöèÊú∫ÊÄßÂíåÂØÜÊñá‰∏çÂèØÂå∫ÂàÜÊÄßÔºåÂ∏∏Áî®‰∫é PQ-KEM/Ê†ºÂØÜÁ†ÅÊ†áÂáÜÂçèËÆÆ‰∏≠„ÄÇ
///
/// Example
/// ```
/// let (K, c) = encaps_internal(ek, m)
/// ```
pub fn encaps_internal(ek : ByteArray, m : ByteArray) -> (ByteArray, ByteArray) {
  // 1. k, r ‚Üê G(m ‚à• H(ek))
  let h_ek = @kem.h(ek)
  let input = m.copy()
  input.append(h_ek)
  let (k, r) = @kem.g(input)
  // 2. c ‚Üê K-PKE.Encrypt(ek, m, r)
  let c = encrypt(ek, m, r)
  // 3. ËøîÂõû (K, c)
  (k, c)
}

///| KEM ÂÜÖÈÉ®Ëß£Â∞ÅË£ÖÂáΩÊï∞ÔºàInternal Decapsulation for KEMÔºâ  
///
/// Parameters
///
/// - `dk` : Êâ©Â±ïÁßÅÈí•Â≠óËäÇÊï∞ÁªÑÔºàByteArrayÔºâÔºåÁî± `keygen_internal` ÁîüÊàêÔºàÂê´ÁßÅÈí•„ÄÅÊâ©Â±ïÂÖ¨Èí•„ÄÅÂìàÂ∏å„ÄÅÈöèÊú∫ÁÜµÔºâ
/// - `c`  : ÂØÜÊñáÂ≠óËäÇÊï∞ÁªÑÔºàByteArrayÔºâÔºåÁî± `encaps_internal` Â∞ÅË£Ö‰∫ßÁîü
///
/// Returns
///
/// - `ByteArray` : ÂçèÂïÜÂá∫ÁöÑÂØπÁß∞ÂØÜÈí• K‚Ä≤ÔºàByteArrayÔºâÔºåÁî®‰∫éÂêéÁª≠Âä†ÂØÜÈÄö‰ø°
///
/// Errors
///
/// - Êó†ÊòæÂºèÈîôËØØÊäõÂá∫Ôºå‰ΩÜ‰æùËµñÔºö  
///   - ÂØÜÈí•„ÄÅÂØÜÊñáÊ†ºÂºè‰∏éÂçèËÆÆÂèÇÊï∞‰∏ÄËá¥  
///   - @kem Áõ∏ÂÖ≥ÂáΩÊï∞ÔºàÂ¶Ç `decrypt`„ÄÅ`encrypt`„ÄÅ`g`„ÄÅ`j`„ÄÅ`constant_time_compare`ÔºâÂùáÂ∑≤ÂÆûÁé∞Âπ∂ÂÆâÂÖ®  
///
/// Description
///
/// ÂÆûÁé∞ KEM Ëß£Â∞ÅË£ÖÔºàÂØÜÈí•ÊÅ¢Â§çÔºâËøáÁ®ãÔºåÂÖ∏Âûã‰∫é PQ-KEM/Ê†ºÂØÜÁ†ÅÂçèËÆÆÔºåÊµÅÁ®ãÂ¶Ç‰∏ãÔºö
///
/// 1. **Êâ©Â±ïÁßÅÈí•ÂàÜËß£**Ôºö  
///    - dk_PKE    = dk Ââç 384k Â≠óËäÇÔºàÂü∫Á°ÄÁßÅÈí•Ôºâ  
///    - ek_PKE    = dk Á¥ßÈöèÂÖ∂ÂêéÁöÑ 384k+32 Â≠óËäÇÔºàÂÖ¨Èí•ÂâØÊú¨Ôºâ  
///    - h         = dk ÁöÑ H(ek) ÂìàÂ∏åÂ≠óÊÆµ  
///    - z         = dk ÁöÑÈöèÊú∫ÁÜµÂ≠óÊÆµ  
///
/// 2. **ÊòéÊñáÊÅ¢Â§ç**Ôºö  
///    - Áî®ÁßÅÈí• dk_PKE Ëß£ÂØÜÂØÜÊñá cÔºåÂæó m‚Ä≤  
///
/// 3. **ÂçèÂïÜÂØÜÈí•ÂÄôÈÄâ‰∏éÈöèÊú∫Êï∞**Ôºö  
///    - k‚Ä≤, r‚Ä≤ = G(m‚Ä≤ ‚à• h)ÔºåÊåâ KEM Ê†áÂáÜÊ¥æÁîü  
///
/// 4. **ÊïÖÈöúÊÅ¢Â§çÂØÜÈí•**Ôºö  
///    - kÃÑ = J(z ‚à• c)ÔºåËã•ÂØÜÊñáÊ†°È™åÂ§±Ë¥•ÔºåÂàôËøîÂõûËØ•ÂØÜÈí•  
///
/// 5. **ÂØÜÊñáÈáçÂä†ÂØÜ‰∏ÄËá¥ÊÄßÊ†°È™å**Ôºö  
///    - Áî® ek_PKE„ÄÅm‚Ä≤„ÄÅr‚Ä≤ ÈáçÊñ∞Âä†ÂØÜÔºåÂæó c‚Ä≤  
///    - Â∏∏Êï∞Êó∂Èó¥ÊØîÂØπ c, c‚Ä≤Ôºö  
///       - Ëã•‰∏ÄËá¥ÔºåÂàôËøîÂõû k‚Ä≤  
///       - ‰∏ç‰∏ÄËá¥ÔºåÂàôËøîÂõû kÃÑÔºàÊäóÈÄâÊã©ÂØÜÊñáÊîªÂáªÔºåÁ°Æ‰øùÂØÜÈí•‰∏çÂèØÂå∫ÂàÜÔºâ  
///
/// Example
/// ```
/// let K = decaps_internal(dk, c)
/// ```
pub fn decaps_internal(dk : ByteArray, c : ByteArray) -> ByteArray {
  let k = 4

  // 1. dk_PKE ‚Üê dk[0 : 384k]
  let dk_PKE = dk[0:384 * k].iter().collect()
  // 2. ek_PKE ‚Üê dk[384k : 768k+32]
  let ek_PKE = dk[384 * k:768 * k + 32].iter().collect()
  // 3. h ‚Üê dk[768k+32 : 768k+64]
  let h = dk[768 * k + 32:768 * k + 64].iter().collect()
  // 4. z ‚Üê dk[768k+64 : 768k+96]
  let z = dk[768 * k + 64:768 * k + 96].iter().collect()

  // 5. m‚Ä≤ ‚Üê K-PKE.Decrypt(dk_PKE, c)
  let m_prime = decrypt(dk_PKE, c)
  // 6. (K‚Ä≤, r‚Ä≤) ‚Üê G(m‚Ä≤ ‚à• h)
  let input = m_prime.copy()
  input.append(h)
  let (k_prime, r_prime) = @kem.g(input)
  // 7. KÃÑ ‚Üê J(z ‚à• c)
  let zc = z.copy()
  zc.append(c)
  let k_bar = @kem.j(zc)
  // 8. c‚Ä≤ ‚Üê K-PKE.Encrypt(ek_PKE, m‚Ä≤, r‚Ä≤)
  let c_prime = encrypt(ek_PKE, m_prime, r_prime)
  // 9-11. if c ‚â† c‚Ä≤ then K‚Ä≤ ‚Üê KÃÑ
  let k_final = if @kem.constant_time_compare(c, c_prime) {
    k_prime
  } else {
    k_bar
  }
  // 12. return K‚Ä≤
  k_final
}

///|
/// ÁîüÊàê n Â≠óËäÇÁöÑÂÆâÂÖ®ÈöèÊú∫Â≠óËäÇÊï∞ÁªÑ
pub fn random_bytes(n : Int) -> ByteArray {
  let rng = @random.Rand::new()
  let arr : Array[Byte] = Array::make(n, 0)
  for i = 0; i < n; i = i + 1 {
    arr[i] = rng.uint(limit=256).to_byte()
  }
  arr
}

///|
/// ML-KEM.KeyGen()
/// ÁîüÊàêÂ∞ÅË£ÖÂÖ¨Èí• ek ÂíåËß£Â∞ÅË£ÖÁßÅÈí• dk
/// @return (ek, dk) ÂÖÉÁªÑ
pub fn ml_keygen() -> (ByteArray, ByteArray) {
  // 1. ÈöèÊú∫ÁîüÊàê d, z
  let d = random_bytes(32)
  let z = random_bytes(32)
  // 3. Ê£ÄÊü•ÈöèÊú∫Êï∞ÁîüÊàêÊòØÂê¶ÊàêÂäü
  if d == [] || z == [] {
    abort("Random bit generation failed")
  }
  // 6. Ë∞ÉÁî®ÂÜÖÈÉ®ÂØÜÈí•ÁîüÊàê
  let (ek, dk) = keygen_internal(d, z)
  // 7. ËøîÂõû
  (ek, dk)
}

///|
/// Ê£ÄÊü•ÂØÜÈí•ÂØπ (ek, dk) ÁöÑ‰∏ÄËá¥ÊÄßÔºàpair-wise consistencyÔºâ
/// @param ek Â∞ÅË£ÖÂÖ¨Èí•
/// @param dk Ëß£Â∞ÅË£ÖÁßÅÈí•
/// @return Bool ÊòØÂê¶‰∏ÄËá¥
pub fn check_pairwise_consistency(ek : ByteArray, dk : ByteArray) -> Bool {
  // i. ÁîüÊàê32Â≠óËäÇÈöèÊú∫Ê∂àÊÅØ
  let m = random_bytes(32)
  // ii. (k, c) ‚Üê ML-KEM.Encaps_internal(ek, m)
  let (k, c) = encaps_internal(ek, m)
  // iii. K‚Ä≤ ‚Üê ML-KEM.Decaps_internal(dk, c)
  let k_prime = decaps_internal(dk, c)
  // iv. Ê£ÄÊü• k == k‚Ä≤
  @kem.constant_time_compare(k, k_prime)
}

///|
/// ML-KEM.Encaps
/// @param ek Â∞ÅË£ÖÂÖ¨Èí•
/// @return (K, c) ÂÖ±‰∫´ÂØÜÈí•‰∏éÂØÜÊñá
pub fn ml_encaps(ek : ByteArray) -> (ByteArray, ByteArray) {
  // 1. m ‚Üê‚Çç$‚Çé ùîπ^{32}
  let m = random_bytes(32)
  // 2. Ê£ÄÊü•ÈöèÊú∫Êï∞ÁîüÊàêÊòØÂê¶ÊàêÂäü
  if m == [] {
    abort("Random bit generation failed")
  }
  // 5. (K, c) ‚Üê ML-KEM.Encaps_internal(ek, m)
  let (k, c) = encaps_internal(ek, m)
  // 6. ËøîÂõû (K, c)
  (k, c)
}

///|
/// ML-KEM.Decaps
/// @param dk Ëß£Â∞ÅË£ÖÁßÅÈí•
/// @param c  ÂØÜÊñá
/// @return   ÂÖ±‰∫´ÂØÜÈí• K
pub fn ml_decaps(dk : ByteArray, c : ByteArray) -> ByteArray {
  // 1. K‚Ä≤ ‚Üê ML-KEM.Decaps_internal(dk, c)
  let k_prime = decaps_internal(dk, c)
  // 2. return K‚Ä≤
  k_prime
}
